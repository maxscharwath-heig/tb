Dans cette chapitre, nous examinerons les travaux et les outils existants liés à l'édition collaborative de document, au chiffrement de bout en bout et au stoquage distribué.
Nous allons aussi également nous penché sur les outils existants.

\section{Edition collaborative de documents}
L'édition collaborative de documents permet à plusieurs utilisateurs de travailler simultanément sur un même document, en fusionnant leurs modifications en temps réel.
Cette section passera en revue les méthodes et protocoles clés utilisés pour permettre cette collaboration, ainsi que les outils et applications populaires.

\section{Méthodes et protocoles existants}

\subsection{Operational Transformation (OT)}

Operational Transformation (OT) est un mécanisme de synchronisation de données en temps réel qui permet de résoudre les conflits entre les modifications concurrentes apportées par les utilisateurs. L'idée clé derrière l'OT est de transformer les opérations de manière à préserver leur intention lorsqu'elles sont appliquées dans un ordre différent. Dans cette section, nous examinerons en détail les concepts et mécanismes fondamentaux de l'OT, ainsi que les algorithmes et systèmes basés sur l'OT.

\subsubsection{Concepts de base}

Pour comprendre le fonctionnement de l'OT, il est important de se familiariser avec les concepts de base suivants:

\begin{itemize}
    \item \textbf{Opération:} Une opération est une action effectuée par un utilisateur sur un document, telle que l'insertion ou la suppression d'un caractère. Les opérations sont généralement représentées par des objets contenant des informations sur l'action effectuée, la position dans le document et, le cas échéant, le caractère inséré ou supprimé.
    \item \textbf{Intention:} L'intention d'une opération est l'effet souhaité de l'opération sur le document. L'OT vise à préserver l'intention des opérations, même lorsqu'elles sont appliquées dans un ordre différent.
    \item \textbf{Conflit:} Un conflit se produit lorsque deux opérations sont effectuées simultanément sur le même document, et que l'application de ces opérations dans un ordre différent peut entraîner des résultats incohérents. L'OT résout les conflits en transformant les opérations concurrentes de manière à préserver leur intention.
\end{itemize}

\subsubsection{Transformation des opérations}

La transformation des opérations est le processus qui permet de modifier les opérations concurrentes de manière à préserver leur intention lorsqu'elles sont appliquées dans un ordre différent. Supposons que nous ayons deux utilisateurs, Alice et Bob, travaillant sur le même document. Les opérations d'Alice et de Bob sont respectivement représentées par $O_A$ et $O_B$. L'OT utilise deux fonctions de transformation, $T_1$ et $T_2$, pour résoudre les conflits éventuels:

\begin{equation}
    O_A' = T_1(O_A, O_B)
\end{equation}

\begin{equation}
    O_B' = T_2(O_B, O_A)
\end{equation}

Ici, $O_A'$ et $O_B'$ sont les opérations transformées. Lorsque les opérations transformées sont appliquées au document, elles préservent l'intention des utilisateurs tout en résolvant les conflits.

\subsubsection{Conditions de transformation}

Pour que la transformation des opérations fonctionne correctement, les fonctions de transformation $T_1$ et $T_2$ doivent satisfaire les conditions suivantes:

\begin{enumerate}
    \item \textbf{Condition TP1:} Si les opérations $O_A$ et $O_B$ sont indépendantes, alors $O_A' = O_A$ et $O_B' = O_B$.
    \item \textbf{Condition TP2:} Si l'opération $O_A$ est appliquée avant l'opération $O_B$ sur un document, puis l'opération $O_B'$ transformée par rapport à $O_A$ est appliquée, le résultat doit être le même que si l'opération $O_B$ était appliquée avant l'opération $O_A$, puis l'opération $O_A'$ transformée par rapport à $O_B$ était appliquée.

          \begin{equation}
              apply(apply(D, O_A), O_B') = apply(apply(D, O_B), O_A')
          \end{equation}

          Ici, $D$ représente l'état initial du document et $apply$ est une fonction qui applique une opération à un document.

    \item \textbf{Condition TP3:} Si les opérations $O_A$ et $O_B$ sont transformées en $O_A'$ et $O_B'$, alors transformer $O_A'$ par rapport à $O_B'$ doit donner $O_A$ et transformer $O_B'$ par rapport à $O_A'$ doit donner $O_B$.

          \begin{equation}
              T_1(O_A', O_B') = O_A
          \end{equation}

          \begin{equation}
              T_2(O_B', O_A') = O_B
          \end{equation}

\end{enumerate}

Ces conditions garantissent que les opérations transformées préservent l'intention des opérations d'origine et que le document final est cohérent pour tous les utilisateurs, quel que soit l'ordre d'application des opérations.

\subsubsection{Algorithmes et systèmes basés sur l'OT}

Au fil des ans, plusieurs algorithmes et systèmes basés sur l'OT ont été développés. Voici quelques exemples notables:

\subsubsection{Algorithme de Jupiter}

Jupiter, un système de collaboration en temps réel basé sur l'OT, a été développé au début des années 1990 par le Xerox Palo Alto Research Center (PARC) pour répondre à la demande croissante de collaboration en ligne sur des documents partagés\cite{jupiter}. Sous la direction de Clarence Ellis, le projet Jupiter a abouti à la publication d'un article en 1995, intitulé "Operational Transformation in Real-Time Group Editors"\cite{ellis1995}, qui présentait pour la première fois les concepts clés et les algorithmes de l'OT.

L'algorithme de Jupiter fonctionne dans un environnement client-serveur où chaque client et le serveur possèdent leur propre copie du document et appliquent les opérations localement\cite{jupiter}. Les opérations sont ensuite transmises au serveur qui les transforme et les redistribue aux autres clients. Pour garantir que les opérations sont transformées et appliquées dans un ordre préservant leur relation de causalité, Jupiter utilise un mécanisme de contrôle de causalité\cite{ellis1995}. Ainsi, si une opération dépend d'une autre (par exemple, effectuée par le même utilisateur après la première), cette dépendance est respectée lors de l'application des opérations.

Bien que Jupiter ne soit plus activement développé ou utilisé, ses concepts et techniques continuent d'influencer de nombreux systèmes et algorithmes ultérieurs de collaboration en temps réel.

\subsubsection{Algorithme de Google Wave}

Google Wave, annoncé en 2009, était un système de collaboration en temps réel développé par Google\cite{googlewave}. Conçu comme une plateforme unifiée de communication et de collaboration, il combinait des fonctionnalités de messagerie instantanée, de courrier électronique, de partage de documents et de médias sociaux. L'objectif de Google Wave était de faciliter la communication et la collaboration en ligne entre les utilisateurs, en permettant des conversations structurées et des modifications de documents en temps réel\cite{googlewave}.

Basé sur l'OT, Google Wave utilisait un modèle décentralisé, où chaque utilisateur maintenait sa propre copie du document et échangeait des opérations directement avec les autres utilisateurs. Cela différait du modèle client-serveur de Jupiter et offrait une plus grande flexibilité pour gérer les modifications hors ligne et synchroniser les données lorsqu'un utilisateur se reconnectait.

Malgré ses ambitions, Google Wave n'a pas réussi à attirer un grand nombre d'utilisateurs, et Google a annoncé l'arrêt du développement de Wave en 2010\cite{googlewaveend}. Néanmoins, certaines des idées et techniques de Wave ont été intégrées dans d'autres produits de collaboration en temps réel de Google, tels que Google Docs, ainsi que dans des projets open source tels que Apache Wave et plus récemment ShareDB\cite{apachewave, sharedb}.

\subsubsection{Limitations et défis de l'OT}

Bien que l'OT soit un mécanisme puissant pour la synchronisation en temps réel des documents et la résolution des conflits, il présente également certaines limitations et défis:

\begin{itemize}
    \item \textbf{Complexité:} Les algorithmes basés sur l'OT peuvent être complexes à mettre en oeuvre et à déboguer, en particulier lorsqu'ils doivent gérer des cas de conflits complexes et des relations de causalité.
    \item \textbf{Performances:} La transformation des opérations et le contrôle de la causalité peuvent avoir un impact sur les performances, surtout lorsque le nombre d'utilisateurs et d'opérations concurrentes augmente.
    \item \textbf{Interopérabilité:} Les systèmes basés sur l'OT peuvent avoir des difficultés à interagir avec d'autres systèmes de synchronisation de données qui n'utilisent pas l'OT, ce qui peut limiter leur applicabilité dans certaines situations.
    \item \textbf{Sémantique des opérations:} Les fonctions de transformation doivent être définies pour chaque type d'opération et chaque structure de données, ce qui peut être délicat lorsque les opérations ont des sémantiques complexes ou interdépendantes.
\end{itemize}

Malgré ces défis, l'OT reste une méthode importante et largement utilisée pour la collaboration en temps réel et la synchronisation des données dans les systèmes distribués.

\subsection{Conflict-Free Replicated Data Types (CRDT)}
\subsubsection{Concepts de base des CRDT}

Les Conflict-Free Replicated Data Types (CRDT) sont des structures de données spécifiques conçues pour résoudre les conflits de manière déterministe lors de la collaboration en temps réel sur des documents partagés\cite{crdt}. Les CRDT ont deux propriétés importantes : ils sont \textit{commutatifs}, ce qui signifie que l'ordre d'application des opérations n'affecte pas le résultat final, et \textit{idempotents}, ce qui signifie que l'application répétée d'une opération a le même effet que l'application unique de cette opération.

Les CRDT sont conçus pour être distribués et répliqués sur plusieurs machines, et ils sont conçus pour être utilisés dans un environnement sans serveur central, où chaque client possède sa propre copie des données. Les clients peuvent modifier les données et les synchroniser entre eux, et les modifications sont fusionnées de manière déterministe pour produire un résultat cohérent.

\subsubsection{Exemples de CRDT pour l'édition de texte}

\paragraph{WOOT}
WOOT (WithOut Operational Transformation) est un algorithme CRDT développé pour l'édition collaborative de documents textuels. Il utilise un modèle de données basé sur des caractères, où chaque caractère est associé à un identifiant unique. Les opérations d'insertion et de suppression sont effectuées localement et propagées aux autres utilisateurs. Les caractères sont insérés et supprimés sans transformation, garantissant ainsi la convergence et la cohérence des documents.

\paragraph{Treedoc}
Treedoc est un autre algorithme CRDT pour l'édition collaborative de documents. Il utilise une structure d'arbre binaire pour stocker les caractères et attribue des identifiants uniques basés sur les positions des caractères dans l'arbre. Les opérations d'insertion et de suppression sont propagées aux autres utilisateurs sans transformation, assurant la cohérence et la convergence des documents.

\paragraph{RGA}
Replicated Growable Array (RGA) est un algorithme CRDT pour l'édition collaborative de documents textuels qui utilise une structure de liste chaînée pour stocker les caractères. Chaque caractère est associé à un identifiant unique, et les opérations d'insertion et de suppression sont propagées sans transformation. La convergence et la cohérence sont garanties par l'ordre des identifiants uniques.

\paragraph{Logoot}
Logoot est un algorithme CRDT basé sur un modèle de données linéaire. Il attribue des identifiants uniques aux positions des caractères plutôt qu'aux caractères eux-mêmes. Les identifiants sont générés en utilisant un mécanisme de densité, permettant un nombre illimité d'insertions entre deux positions existantes. Les opérations d'insertion et de suppression sont propagées sans transformation, garantissant la convergence et la cohérence des documents.

\paragraph{LSEQ}
LSEQ (Logoot-Sequence) est un algorithme CRDT pour l'édition collaborative de documents textuels qui étend l'algorithme Logoot. Il utilise un mécanisme d'allocation d'identifiants basé sur une fonction de densité variable, réduisant ainsi la taille des identifiants et améliorant l'efficacité de l'algorithme. LSEQ garantit également la convergence et la cohérence des documents.

\subsubsection{Systèmes actuels basés sur CRDT}

Plusieurs systèmes et bibliothèques actuels utilisent les CRDT pour permettre la collaboration en temps réel sur des documents partagés. Parmi les exemples notables, on trouve Automerge, Yjs et Riak.

\paragraph{Automerge\cite{automerge}}

Automerge est une bibliothèque JavaScript permettant de développer des applications collaboratives en temps réel, telles que des éditeurs de texte et des tableaux Kanban. Automerge utilise des CRDT pour assurer la synchronisation des données entre les différentes instances de l'application, tout en maintenant la cohérence et en résolvant les conflits.

\paragraph{Yjs\cite{yjs}}

Yjs est une bibliothèque JavaScript de collaboration en temps réel, qui utilise également les CRDT pour la synchronisation des données. Yjs prend en charge un large éventail de structures de données et de fonctionnalités, y compris la collaboration sur des documents texte, des tableaux et des graphes.

\paragraph{Riak\cite{riak}}

Riak est une base de données distribuée et décentralisée, conçue pour offrir une grande disponibilité et une tolérance aux partitions. Riak utilise des CRDT pour assurer la cohérence des données entre les noeuds du système, permettant ainsi aux clients d'effectuer des opérations de lecture et d'écriture même en cas de défaillance partielle du réseau.